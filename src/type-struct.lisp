;;;; internal representation of types
(in-package :static-types)

(defclass type-scheme () ()
  (:documentation "the abstract superclass of all types"))

(defmacro def-type-class (class-name slots format-args &key
                                                         (documentation "generated by DEF-TYPE-CLASS")
                                                         print-type
                                                         print-identity
                                                         constructor-arglist
                                                         constructor-arglist-types)
  "define a class used to represent a type, and derive several methods.

if CONSTRUCTOR-ARGLIST is supplied, CONSTRUCTOR-ARGLIST-TYPES must be as well. the arglist should bind all of the SLOT-NAMEs as args."
  (labels ((slot-descriptor-name (slot-descriptor)
             (first slot-descriptor))
           
           (slot-descriptor-type (slot-descriptor)
             (second slot-descriptor))
           
           (accessor-name (slot-name)
             (symbol-concatenate class-name '- slot-name))
           
           (slot-accessor-declamation (slot)
             `(ftype (function (,class-name) ,(slot-descriptor-type slot))
                     ,(accessor-name (slot-descriptor-name slot))))

           (canonicalize-slot (slot-descriptor)
             (destructuring-bind (slot-name slot-type) slot-descriptor
               `(,slot-name
                 :initform (error "required field uninit")
                 :initarg ,(make-keyword slot-name)
                 :type ,slot-type
                 :accessor ,(accessor-name slot-name))))

           (slot-initializer-arg (slot-name)
             (list (make-keyword slot-name)
                   slot-name)))
    
    (let* ((constructor-name (symbol-concatenate 'make- class-name))
           (slot-names (mapcar #'slot-descriptor-name slots))
           (real-constructor-arglist (or constructor-arglist slot-names))
           (real-constructor-arglist-types (or constructor-arglist-types
                                               (mapcar #'slot-descriptor-type slots))))
      
      `(progn
         (declaim ,@(mapcar #'slot-accessor-declamation slots))
         
         (defclass ,class-name (type-scheme)
           ,(mapcar #'canonicalize-slot slots)
           (:documentation ,documentation))
         
         (declaim (ftype (function ,real-constructor-arglist-types ,class-name)
                         ,constructor-name))
         (defun ,constructor-name ,real-constructor-arglist
           (make-instance ',class-name
                          ,@(alexandria:mappend #'slot-initializer-arg
                                                slot-names)))

         (defmethod print-object ((object ,class-name) stream)
           (print-unreadable-object (object stream :type ,print-type
                                            :identity ,print-identity)
             (with-slots ,slot-names object
               (format stream ,@format-args))))))))

(def-type-class forall-type
    ((arguments (trivial-types:proper-list type-variable))
     (body type-scheme))
  ("forall ~a. ~a" arguments body))

(def-type-class arrow-type
    ((input type-scheme)
     (output type-scheme))
  ("~a -> ~a" input output))

(def-type-class primitive-type
    ((name symbol))
  ("~a" name)
  :documentation "NAME should be a symbol which names a Common Lisp type

ideally, NAME should name a reasonable representational type, which
SBCL can do something useful with.

note the assumption that, if an object is valid at a type at one point
during compilation or execution, it must be valid at that type during
all of compilation and execution. that is, if an operation changes a
`thing' (i intentionally avoid using `object' here) from being valid
at a type T to being invalid at T, that `thing' must no longer hash as
EQ to its previous self. this invariant should be very easy to
enforce, unless you mutate an object so that it no longer meets a
SATISFIES type. the easiest way to avoid all these pitfalls is to
1. never mutate an object and 2. never write a SATISFIES type
specifier.

for no particular reason, we currently require that NAME be a
symbol. if you need to represent a type like (ARRAY FIXNUM), you can
bind it to a symbol by doing (DEFTYPE ARRAY-OF-FIXNUM () '(ARRAY
FIXNUM)).")

(def-type-class type-variable
    ((name symbol))
  ("~a" name)
  :constructor-arglist (&optional (name (gensym "TYPE-VARIABLE-")))
  :constructor-arglist-types (&optional symbol))
