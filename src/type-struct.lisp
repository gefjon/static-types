;;;; internal representation of types
(in-package :static-types)

(defclass type-scheme ()
  :documentation "the abstract superclass of all types")

(defmacro def-type-class (class-name slots format-args &key
                                                         (documentation "generated by DEF-TYPE-CLASS")
                                                         print-type
                                                         print-identity
                                                         superclasses)
  "define a class used to represent a type, and derive several methods.

if CONSTRUCTOR-ARGLIST is supplied, CONSTRUCTOR-ARGLIST-TYPES must be as well. the arglist should bind all of the SLOT-NAMEs as args."
  (let* ((slot-names (mapcar #'gefjon-utils::slot-descriptor-name slots)))
    
    `(progn
       (defclass ,class-name ,slots :documentation ,documentation
                 :superclasses ,(cons 'type-scheme
                                     superclasses))
       (defmethod print-object ((object ,class-name) stream)
         (print-unreadable-object (object stream :type ,print-type
                                          :identity ,print-identity)
           (with-slots ,slot-names object
             (format stream ,@format-args)))))))

(def-type-class forall-type
    ((arguments (trivial-types:proper-list type-variable))
     (body type-scheme))
  ("forall ~a. ~a" arguments body))

(def-type-class arrow-type
    ((input type-scheme)
     (output type-scheme))
  ("~a -> ~a" input output))

(def-type-class primitive-type
    ((name symbol))
  ("~a" name)
  :documentation "NAME should be a symbol which names a Common Lisp type

ideally, NAME should name a reasonable representational type, which
SBCL can do something useful with.

note the assumption that, if an object is valid at a type at one point
during compilation or execution, it must be valid at that type during
all of compilation and execution. that is, if an operation changes a
`thing' (i intentionally avoid using `object' here) from being valid
at a type T to being invalid at T, that `thing' must no longer hash as
EQ to its previous self. this invariant should be very easy to
enforce, unless you mutate an object so that it no longer meets a
SATISFIES type. the easiest way to avoid all these pitfalls is to
1. never mutate an object and 2. never write a SATISFIES type
specifier.

for no particular reason, we currently require that NAME be a
symbol. if you need to represent a type like (ARRAY FIXNUM), you can
bind it to a symbol by doing (DEFTYPE ARRAY-OF-FIXNUM () '(ARRAY
FIXNUM)).")

(def-type-class type-variable
    ((name symbol))
  ("~a" name)
  :superclasses (var))

(defun new-type-variable ()
  (make-type-variable (gensym "type-var-")))
